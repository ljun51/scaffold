# 数据库概念

## HTAP、OLTP、OLAP
* HTAP：混合事务/分析处理（Hybrid Transactional/Analytical Processing）
* OLTP：联机事务处理（On-Line Transaction Processing）
* OLAT：联机分析处理（On-Line Analytical Processing）

## PL
PL 是一种过程化程序语言（Procedural Language，PL）。它是对 SQL 的扩展，在普通 SQL 语句的基础上增加了编程语言的特点，把数据操作和查询语句组织在 PL 代码的过程化代码中，通过逻辑判断、循环等操作实现复杂的功能。

使用 PL 可以编写具有很多高级功能的程序，能够把业务逻辑封装在数据库内部，提供更好的抽象性和安全性，同时减少了网络的交互，调用速度更快，从而提升整体性能。

## ACID
在数据库管理系统（DBMS）中，**ACID** 是一组用于保证数据在事务中的一致性、完整性和可靠性的属性。让我们深入了解一下 **ACID** 的四个关键特性：

1. **原子性（Atomicity）**：
   - 原子性意味着事务要么完全执行，要么完全不执行。不存在中间状态。
   - 每个事务被视为一个单元，要么执行完毕，要么根本不执行。
   - 涉及以下两个操作：
     - **中止（Abort）**：如果事务中止，对数据库所做的更改不会被显示。
     - **提交（Commit）**：如果事务提交，所做的更改将被显示。
   - 原子性也被称为“全有或全无规则”。

2. **一致性（Consistency）**：
   - 一致性意味着在事务之前和之后，完整性约束必须得到维护，以确保数据库的一致性。
   - 例如，考虑以下事务 T，其中包含 T1 和 T2：从账户 X 转账 100 到账户 Y。
     - 如果事务在 T1 完成后但在 T2 完成之前失败（例如，在执行 write(X) 后但在执行 write(Y) 之前），那么金额已从 X 扣除，但未添加到 Y。这导致了不一致的数据库状态。因此，必须完整地执行事务，以确保数据库状态的正确性。

3. **隔离性（Isolation）**：
   - 隔离性确保多个事务可以并发发生，而不会导致数据库状态的不一致。
   - 事务独立运行，互不干扰。
   - 此属性确保并发执行的事务将产生与按某种顺序串行执行相等的状态。
   - 例如，两个事务 T 和 T”，假设 T 已执行到 Read(Y)，然后 T” 开始。由于操作交错，T” 读取了 X 的正确值，但 Y 的错误值，T” 计算的总和（X+Y = 50,000+500=50,500）与事务结束时的总和不一致：T：(X+Y = 50,000 + 450 = 50,450)。这导致了数据库的不一致。

4. **持久性（Durability）**：
   - 持久性确保一旦事务提交，其更改将永久保存在数据库中，即使发生故障、断电或其他意外情况。
   - 数据库的更改应该是持久的，不会因为系统故障而丢失。

**ACID** 是数据库事务的关键特性，确保数据的一致性、完整性和可靠性。

## 并发一致性问题
数据库中的并发一致性问题是在多个事务同时操作数据库时可能出现的一系列问题。这些问题会破坏事务的隔离性，导致数据不一致。让我们详细探讨一下这些问题以及如何解决它们：

1. **丢失修改问题**：
   - 两个事务同时修改同一数据，后一个事务的修改覆盖了前一个事务的修改。
   - 解决方法：使用事务控制，确保事务要么全部执行成功，要么全部回滚。

2. **读脏数据问题**：
   - 一个事务在中途对数据进行修改，另一个事务读取了这个临时状态的数据。
   - 解决方法：通过并发控制来保证隔离性，例如使用封锁机制。

3. **不可重复读问题**：
   - 一个事务多次读取同一数据，但结果不同，因为其他事务在期间对数据进行了修改。
   - 解决方法：使用更严格的隔离级别，例如可重复读。

4. **幻影读问题**：
   - 一个事务读取某个范围的数据，另一个事务在这个范围内插入了新的数据，导致第一个事务再次读取时结果不同。
   - 解决方法：使用更严格的隔离级别，例如串行化。

这些问题的解决方案包括事务控制、锁机制和隔离级别设置。数据库管理系统提供了不同的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

## 事务的隔离等级
数据库事务的隔离级别共有四种，它们分别是：

1. **读未提交（READ UNCOMMITTED）**：
   - 最低级别的隔离，不加锁，性能最好。
   - 允许读取其他事务未提交的数据，可能导致脏读问题。
   - 不适合要求严格数据一致性的场景。

2. **读提交（READ COMMITTED）**：
   - 允许读取其他事务已提交的数据。
   - 避免了脏读，但仍可能出现不可重复读和幻读问题。

3. **可重复读（REPEATABLE READ）**：
   - 保证在一个事务内，同一批数据在事务开始到结束之间保持一致。
   - 避免了脏读和不可重复读，但仍可能出现幻读问题。

4. **串行化（SERIALIZABLE）**：
   - 最高级别的隔离，完全串行化执行事务。
   - 避免了脏读、不可重复读和幻读，但性能较差。

选择隔离级别时需要权衡性能和数据安全，其中**可重复读**是 MySQL 的默认级别。不同隔离级别解决了不同的数据问题，如下所示：

- **脏读**：只有**串行化**的隔离级别解决了。
- **不可重复读**：**读提交**和**可重复读**解决了。
- **幻读**：只有**串行化**的隔离级别解决了。

您可以通过以下语句查看当前数据库的隔离级别：

```sql
SHOW VARIABLES LIKE 'transaction_isolation';
```

MySQL 中执行事务时，事务的执行过程如下：

1. 使用 `BEGIN` 或 `START TRANSACTION` 开始事务。
2. 执行一系列操作。
3. 最后执行 `COMMIT` 操作，或者进行回滚操作（`ROLLBACK`）。

如果您想查看当前有多少事务正在运行，可以使用以下语句：

```sql
SELECT * FROM information_schema.innodb_trx;
```

请根据业务需求选择合适的隔离级别，平衡性能和数据安全。

## ACID靠什么保证

1. **A原子性(atomicity)** 由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
2. **C一致性(consistency)** 一般由代码层面来保证
3. **I隔离性(isolation)** 由MVCC来保证
4. **D持久性(durability)** 由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复

## SQL 优化的实践经验

* 对查询进行优化，要尽量避免全表扫描，首先应考虑在 `where` 及 `order by` 涉及的列上建立索引。
* 应尽量避免在 `where` 子句中对字段进行 `NULL` 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

```sql
SELECT id FROM t WHERE num IS NULL
```

最好不要给数据库留 `NULL`，尽可能的使用 `NOT NULL` 填充数据库.备注、描述、评论之类的可以设置为 `NULL`，其他的，最好不要使用 `NULL`。

* 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
   
* 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：
```sql
select id from t where num=10 or Name = 'admin'
```
可以这样查询：
```sql
select id from t where num = 10
union all
select id from t where Name = 'admin'
```
* in 和 not in 也要慎用，否则会导致全表扫描，如：
```sql
select id from t where num in(1,2,3)
```
对于连续的数值，能用 between 就不要用 in 了：
```sql
select id from t where num between 1 and 3
```
很多时候用 exists 代替 in 是一个好的选择：
```sql
select num from a where num in(select num from b)
```
用下面的语句替换：
```sql
select num from a where exists(select 1 from b where num=a.num)
```
* 下面的查询也将导致全表扫描：
```sql
select id from t where name like ‘%abc%’
```
若要提高效率，可以考虑全文检索。

* 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
```sql
select id from t where num = @num
```
可以改为强制查询使用索引：
```sql
select id from t with(index(索引名)) where num = @num
```
应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
```sql
select id from t where num/2 = 100
```
应改为:
```sql
select id from t where num = 100*2
```

* 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
```sql
select id from t where substring(name,1,3) = ’abc’       -- name以abc开头的id
select id from t where datediff(day,createdate,’2005-11-30′) = 0    -- ‘2005-11-30’    --生成的id
```
应改为:
```sql
select id from t where name like 'abc%'
select id from t where createdate >= '2005-11-30' and createdate < '2005-12-1'
```

* 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

* 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

* Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。

* 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。

* select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。

* 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

* 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。

* 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

* 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

* 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

* 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。

* 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

* 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

* 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

* 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

* 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

* 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。

* 尽量避免大事务操作，提高系统并发能力。

* 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。

* 在 **MySQL** 中，**`IN`** 子句用于在一个字段中匹配多个值。然而，**`IN`** 子句有一个限制，即最大数量以用于索引。这个限制的原因是查询优化器在执行查询计划时需要将所有值加载到内存中，以便快速匹配。如果 **`IN`** 子句中的值太多，则可能会导致内存不足的问题，从而影响性能。

默认情况下，**MySQL** 中 **`IN`** 子句的最大数量以用于索引为 **1500**（也有说 **1000** 的，需要验证）。这意味着在一个 **`IN`** 或 **`NOT IN`** 子句中可以包含最多 **1500** 个值。如果查询中包含的值超过了这个限制，**MySQL** 会抛出“Error Code: 1241”。

因此，如果您的查询中包含的值较多，您可以考虑拆分查询或使用其他方式来处理这些数据。

## 常见数据库
### MySQL
### PostgreSQL
### Oracle
### SQL Server
### Oceanbase
### TiDB
### MongoDB