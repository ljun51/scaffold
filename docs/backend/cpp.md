# C++

## 静态库
`.a` 为静态库文件

## 动态库
`.so` 为动态库文件，运行时动态加载的库文件。

## LD_LIBRARY_PATH
**LD_LIBRARY_PATH** 是一个在 Unix-like 操作系统（包括 Linux）中使用的环境变量，用于指定共享库（shared libraries）的搜索路径。让我们深入了解一下：

1. **LD_LIBRARY_PATH 是什么？**
    - `LD_LIBRARY_PATH` 是 Unix-like 操作系统中的一个环境变量。
    - 它被系统的链接器（`ld`）使用。
    - 该环境变量指定了一组目录，链接器会首先在这些目录中搜索共享库，然后再搜索标准的目录。
    - 这允许用户覆盖系统默认的共享库。

2. **LD_LIBRARY_PATH 的工作原理**：
    - 当程序运行时，它通常依赖于所谓的动态链接的共享对象库（`.so` 文件），这些库包含程序在运行时可以使用的代码。
    - 默认情况下，链接器 `ld` 会在 `/lib`、`/usr/lib` 和 `/etc/ld.so.conf` 中列出的目录中查找这些库。
    - 但是，如果设置了 `LD_LIBRARY_PATH` 环境变量，链接器 `ld` 将首先在该环境变量中列出的目录中查找这些库。
    - 这允许用户指定自己的共享库版本，覆盖系统默认的库。

3. **如何使用 LD_LIBRARY_PATH**：
    - 可以使用标准的修改环境变量的命令来操作 `LD_LIBRARY_PATH`。
    - 查看当前 `LD_LIBRARY_PATH` 的值：
      ```
      echo $LD_LIBRARY_PATH  
      ```
    - 要将目录添加到 `LD_LIBRARY_PATH`，使用以下语法：
      ```
      export LD_LIBRARY_PATH=<your-directory>:$LD_LIBRARY_PATH
      ```
    - 此命令将在现有的 `LD_LIBRARY_PATH` 前面添加你的目录。请注意，目录的搜索顺序与它们在变量中的顺序一致。因此，如果你的目录和系统库目录中都有相同的库，链接器将使用你的目录中的版本。

4. **对系统性能和安全性的影响**：
    - **性能**：`LD_LIBRARY_PATH` 对系统性能有重大影响。如果不慎使用，可能会导致使用不如系统库路径中优化的库，从而降低程序性能。但正确使用时，它允许使用更优化或更新的库，从而提高程序性能。
    - **安全性**：虽然 `LD_LIBRARY_PATH` 很方便，但也存在安全风险。由于它可以覆盖系统库，可能被利用来注入恶意代码。例如，攻击者可以将 `LD_LIBRARY_PATH` 设置为包含常见库的恶意版本，欺骗程序使用它们。

总之，`LD_LIBRARY_PATH` 是 Linux 生态系统中一个强大的工具，允许用户灵活地管理程序如何查找和使用共享库。但在使用时务必谨慎，考虑其对系统性能和安全性的影响。

如果动态库和静态库同时存在，将优先使用动态库。

## makefile
INCLUDEDIR
LIBDIR

## gdb

## $?
`$?` 是一个特殊的 shell 变量，用于获取上一个执行的命令的退出状态码（返回值）。在 Unix/Linux 系统中，命令成功执行时返回 0，否则返回非零值。因此，你可以使用 `$?` 来检查上一个命令是否成功执行。

## fork
fork 后父进程和子进程的执行顺序是不确定的。

## 共享内存
* 共享内存不能自动扩展，只能采用 C++ 内置的数据类型。
* 共享内存不能采用 STL 容器，也不能使用移动语义
* 如果要实现多进程的生产/消费者模型，只能采用循环队列

相关函数：
* shmget 创建或获取共享内存
* shmat 把共享内存连接到当前进程的地址空间
* shmctl 删除共享内存

### 操作共享内存命令
* ipcs
* ipcrm

## 信号量
